---
layout: post
title:  堆排序算法和败者树归并排序算法
date:   2020-06-26 10:18:00 +0800
categories: golang
tags: 堆排序,胜者树,堆树,败者树,多路归并
---

## 堆排序

### 概念及思路

* 堆的定义：数列中的第i数据大于等于2i和2i+1数据视为大顶堆；如果第i数据小于等于2i和2i+1数据视为小顶堆。堆可以用一棵完全二叉树表示，按数列从前向后按层级排列成一棵完全二叉树。

比如{49, 38, 65, 97, 76, 13, 27, 49}，调整成的大顶堆后二叉树结果如下：

```
        --------97--------
        |                |
    ----76----       ----65----
    |        |       |        |
----49       49      13       27
|
38
```

* 调整大顶堆步骤：

1. 从大顶堆根节点A开始，比较A的左子节点L和右子节点R，选出左右子节点的大值比如是L；
2. 将L和A值进行比较，如果L大于A，则交换L和A的值，然后以L为根节点重复执行步骤1，2直到叶子节点为止；如果L小于A说明以A为根节点的完全二叉树已是大顶堆，调整完毕。

* 无序序列生成大顶堆：从最后一个非叶子节点开始执行《调整大顶堆步骤》，然后倒数第二个非叶子节点执行《调整大顶堆步骤》，直到根节点结束。

### 堆排序代码

```
package main

import (
	"fmt"
)

// 调整大顶堆
func heapAdjust(arr []int, s, e int) {
	for i := 2*s; i <= e; i *= 2 {
		// 比较左右子节点的值
		if i < e && arr[i] <= arr[i+1] {
			i++
		}
		if (arr[s] >= arr[i]) {
			break
		}
		arr[s], arr[i] = arr[i], arr[s]
		s = i
	}
}

func heapSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr
	}
	// 为了方便计算，将数组第0个数据保留置空，从1开始是真实数据
	arr = append([]int{0}, arr...)

	// 生成大顶堆
	// 从最小的非叶子节点开始调整堆，直到第一个数据为止，最后整个序列便是大顶堆
	for i := (len(arr)-1)/2; i >= 1; i-- {
		heapAdjust(arr, i, len(arr)-1)
	}
	// 将堆顶数据放到最后，然后调整大顶堆，依次将堆顶数据放到最后，便排序完成
	for i := len(arr)-1; i >= 1; i-- {
		// 第一个数据和最后一个数据交换
		arr[i], arr[1] = arr[1], arr[i]
		heapAdjust(arr, 1, i-1)
	}

	return arr[1:]
}

func main() {
	arr := []int{49, 38, 65, 97, 76, 13, 27, 49}
	arr = heapSort(arr)
	fmt.Println(arr)
}
```

## 败者树归并排序

### 概念及思路

排序过程中涉及到磁盘读取便是外部排序，如果数据量特别大进行一次内部排序内存不够用，则需要将数据切分成多段，每一小段会进行内部排序然后排序好的小段数据写入磁盘。最后将排序好的小段数据进行归并排序，形成整段有序序列存入磁盘。最简单实现多路归并的方法是进行递归两两归并，但是这种方式会产生很多的磁盘读取，为了提高归并性能减少磁盘读取，便产生了败者树。

败者树：败者树叶子节点指向各个归并段，第一个叶子节点对应0号归并段，第二个叶子节点对应1号归并段，依次类推。每个败者树非叶子节点中存放的是归并段编号，0节点存的是所有归并段中第一个数据最小的归并段编号，其它非叶子节点存放的是左右子节点比较后的败者归并段编号。

调整败者树：
假设ls已经是一个败者树，如果从ls[0]号归并段取出第一个数据后，需要重新取ls[0]号归并段第一个元素进行败者树调整。ls[0]编号的归并段新数据与父节点所存编号的归并段第一个数据进行比较，将败者的归并段编号写入父节点，依次向上比较直到败者树的1号节点，最后将胜者编号写入败者树0号节点。

生成败者树：遍历所有叶子节点即归并段，每个归并段都进行一次《调整败者树》。

### 败者树归并排序代码

```
package main

import (
	"fmt"
	"math"
)

const (
	MinVal = math.MinInt32
	MaxVal = math.MaxInt32
)

// 多个有序归并段，最后汇总成一个有序集
func merge(b ...[]int) []int {
	if len(b) == 0 {
		return []int{}
	}
	if len(b) == 1 {
		return b[0]
	}
	// 在每个归并段的最后添加MaxVal，用于判定归并段结束
	for i := 0; i < len(b); i++ {
		b[i] = append(b[i], MaxVal)
	}
	// 新增一个辅助归并段，用于初始化败者树
	b = append(b, []int{MinVal})

	// 创建败者树，败者树中存放的值是归并段的编号
	ls := make([]int, len(b))

	// 初始化败者树
	createLoserTree(b, ls)
	// 汇总结果
	result := []int{}
	for b[ls[0]][0] != MaxVal {
		p := ls[0]
		result = append(result, b[p][0])
		b[p] = b[p][1:]
		adjust(b, ls, p)
	}
	return result
}

// 调整败者树
// @param s int 归并段编号
func adjust(b [][]int, ls []int, s int) {
	// k表示败者树长度
	k := len(ls) - 1
	// 败者树父节点编号
	t := (s + k) / 2
	for t > 0 {
		// s用于表示胜者归并段编号
		if b[ls[t]][0] < b[s][0] {
			s, ls[t] = ls[t], s
		}
		t = t / 2
	}
	ls[0] = s
}

// 创建败者树
func createLoserTree(b [][]int, ls []int) {
	// 败者树长度
	k := len(ls)-1
	// 将败者树所有节点初始化为归并段编号k
	for i := 0; i < len(ls); i++ {
		ls[i] = k
	}
	for i := k-1; i >= 0; i-- {
		adjust(b, ls, i)
	}
}

func main() {
	b0 := []int{10, 15, 16}
	b1 := []int{9, 18, 20}
	b2 := []int{20, 22, 40}
	b3 := []int{6, 15, 25}
	b4 := []int{12, 37, 48}
	arr := merge(b0, b1, b2, b3, b4)
	fmt.Println(arr)
}
```
